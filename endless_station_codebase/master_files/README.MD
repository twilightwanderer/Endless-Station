# Список редактирования оригинального кода

# Руководство по модуляризации

Данный стиль взят с опыта [Nova Sector](https://github.com/NovaSector/NovaSector/tree/master/modular_nova)

# Вступление

Разработка и поддержка отдельной кодовой базы - это большая задача, с которой многие не справились и пострадали от последствий, таких как устаревший и грязный код. Это не обязательно вина недостаточного мастерства людей, которые его поддерживают, просто нехватка ресурсов и то, сколько постоянных усилий требует такое начинание.
Одно из решений этой проблемы - основывать наш сервер на прочной кодовой базе, которая в основном поддерживается кем-то другим, в данном случае tgstation, и вставлять наш контент модульно, следуя при этом общему направлению кода (но не геймплея), зеркально отражая все изменения, которые они делают для паритета.
Git, как система контроля версий, очень полезен, однако это просто очень методичная вещь, которая следует множеству алгоритмов, которые, к сожалению, не всегда могут разумно разрешить некоторые изменения в коде однозначным образом, давая нам конфликты, которые нужно разрешать вручную.
Поскольку удобство сопровождения является одной из основных причин нашего перехода на другую кодовую базу, этот протокол будет серьезно соблюдаться. Хорошо организованный, документированный и атомизированный код избавит наших сопровождающих от головной боли во время рецензирования. Не сваливайте на них работу, которую вы могли бы сделать сами.
Этот документ будет обновляться и изменяться каждый раз, когда в него будут добавляться новые исключения. Возможно, время от времени стоит проверять, не определили ли мы более уникальный стандартизированный способ обработки какого-то общего изменения.

# Проверяйте свои запросы

Вы несете ответственность за тестирование вашего контента. Вы не должны помечать запрос на выгрузку как готовый к рассмотрению, пока не протестируете его. Если вам нужен отдельный клиент для тестирования, вы можете использовать гостевой аккаунт, выйдя из BYOND и подключившись к вашему тестовому серверу. Тестовые слияния не предназначены для поиска ошибок, они предназначены для стресс-тестов, когда локальное тестирование просто не позволяет этого сделать.

## Природа конфликтов

Например, пусть у нас есть оригинал

```dm
var/something = 1
```

в коде ядра, который мы решили изменить с 1 на 2 на нашей стороне,

```diff
- var/something = 1
+ var/something = 2 // NOVA EDIT CHANGE - ORIGINAL: var/something = 1
```

но затем наш апстрим вносит изменения в свою кодовую базу, меняя ее с 1 на 4

```diff
- var/something = 1
+ var/something = 4
```

Как бы ни был прост этот пример, он приводит к относительно простому конфликту в виде

```dm
var/something = 2 // NOVA EDIT CHANGE - ORIGINAL: var/something = 4
```

где мы выбираем предпочтительный вариант вручную.

## Решение конфиликтов

Это то, что не может и, скорее всего, не должно быть решено автоматически, потому что это может привести к ошибкам и багам, которые будет очень сложно отследить, не говоря уже о более сложных примерах конфликтов, таких как изменения, которые включают в себя добавление, удаление и перемещение строк кода по всему пространству.
Git старается изо всех сил, но в конечном итоге это просто тупая программа, поэтому мы должны сами сделать так, чтобы он мог выполнять большую часть работы, минимизируя усилия, затрачиваемые на ручное участие, в тех случаях, когда конфликты будут неизбежны.
Наш ответ на это - модуляризация кода.
Модулизация означает, что большинство изменений и дополнений, которые мы делаем, будут храниться в отдельной папке modular_nova/, как можно более независимой от основного кода, а те, которые абсолютно не могут быть модулированы, должны быть надлежащим образом отмечены комментариями, указывающими, где начинаются изменения, где они заканчиваются, и к какой функции они относятся, но об этом подробнее в следующем разделе.

# Протокол модуляризации

Всегда начинайте с размышлений о теме/цели вашей работы. Часто бывает полезно посмотреть, нет ли уже существующей темы, которую вы должны дополнить.
Если это специфичный для tgcode твик или багфикс, то первым шагом должна быть попытка обсудить и пиарить его в апстрим, вместо того, чтобы без нужды модульно переписывать его здесь.
В противном случае, выберите новый ID для вашего модуля. Например, `DNA-FEATURE-WINGS` или `XENOARCHEAOLOGY` или `SHUTTLE_TOGGLE` - мы будем использовать его в будущей документации. По сути, это идентификатор вашего модуля. Он должен быть единым для всего модуля. Все ссылки ДОЛЖНЫ быть одинаковыми. Это нужно для того, чтобы облегчить поиск.
Затем вам нужно создать основную папку, из которой вы будете работать, которая обычно является идентификатором вашего модуля. Например, `modular_nova/modules/shuttle_toggle`

## Карты

Когда вы добавляете новый элемент на карту, вы ДОЛЖНЫ следовать этой процедуре: Начните с того, что решите, насколько большим будет изменение, если это небольшое изменение на 1 предмет, вы должны использовать простой автоматизатор области. Если это целая комната, то используйте автоматизатор шаблонов.
У нас больше не будет версий карт `_nova`.
НЕ ИЗМЕНЯЙТЕ КАРТЫ TG, ОНИ ОТВЕЧАЮТ ТЕМ ЖЕ СТАНДАРТАМ, ЧТО И ИКОНКИ. ДЛЯ ВНЕСЕНИЯ ИЗМЕНЕНИЙ В КАРТЫ ИСПОЛЬЗУЙТЕ ВЫШЕУКАЗАННЫЕ СПОСОБЫ.
Автомаппер использует готовые шаблоны для переопределения секций карты, используя координаты для определения начального местоположения. Примеры смотрите в файле `automapper_config.toml`.
Автомаппер простых областей использует записи точек отсчета, чтобы поместить один элемент в область карты, которая имеет определенный смысл.

## Ассеты: картинки, звуки, иконки, блобы.

Git не очень хорошо справляется с конфликтами бинарных файлов, поэтому изменения бинарных файлов ядра категорически запрещены, если только у вас нет действительно очень **очень** веской причины поступить иначе.
Все добавленные нами активы должны быть помещены в ту же модульную папку, что и ваш код. Это означает, что все хранится в папке модуля, звуки, иконки и файлы кода.
**Примкер:** Вы добавляете нового моба Лаваланда.

- Прежде всего, вы создаете свою модульную папку. Например, `modular_nova/modules/lavalandmob`.
- Затем вы захотите создать подпапки для каждого компонента. Например, `/code` для кода, `/sounds` для звуковых файлов и `/icons` для любых файлов иконок.
- После этого вам нужно будет установить ссылки внутри кода.

```dm
/mob/lavaland/newmob
    icon = 'modular_nova/modules/lavalandmob/icons/mob.dmi'
    icon_state = "dead_1"
    sound = 'modular_nova/modules/lavalandmob/sounds/boom.ogg'
```

Это обеспечит полную модульность вашего кода и облегчит его редактирование в будущем.

- С другими активами, двоичными файлами и инструментами, обычно следует поступать аналогичным образом, в зависимости от конкретного случая. Если вы сомневаетесь, обратитесь к сопровождающему или другим соавторам за советами и предложениями.
- Любые дополнительные файлы иконок одежды, которые вы добавляете, ДОЛЖНЫ входить в существующие файлы в разделе одежды `master_files`.

## Папка `master_files`

Вы всегда должны помещать любые модульные переопределения иконок, звука, кода и т.д. в эту папку, и она должна соответствовать расположению папок основного кода.
Пример:` code/modules/mob/living/living.dm` -> `modular_nova/master_files/code/modules/mob/living/living.dm`
Это сделано для того, чтобы было проще понять, что изменилось в базовом файле, без необходимости копаться в определениях процедур.
Это также помогает предотвратить ненужное переопределение модулями одной и той же процедуры несколько раз. Более подробная информация об этих типах правок будет представлена позже.

## Полностью модульные части вашего кода

Этот раздел будет довольно простым, однако я постараюсь рассказать об основах и привести простые примеры, так как руководство ориентировано на новичков.
Правило заключается в том, что если вы не должны делать никаких изменений в файлах основной кодовой базы. За некоторыми исключениями, которые будут упомянуты в ближайшее время.
Вкратце, большая часть модульного кода будет размещена во вложенных папках вашей основной папки модуля **`modular_nova/modules/yourmodule/code/`**, с теми же правилами, что и с активами. Не отражайте структуру папок основного кода в папке модуля.
Например, `modular_nova/modules/xenoarcheaology/code`, содержащая весь код, инструменты, предметы и механизмы, связанные с ней.
Такие модули, если только они не очень простые, \*\*должны иметь `readme.md` в своей папке, содержащий следующее:

- ссылки на PR, в которых реализован этот модуль или внесены в него какие-либо существенные изменения
- краткое описание модуля
- список файлов, изменённых в коде ядра, с кратким описанием изменений, а также список изменений в других модульных файлах, не являющихся частью того же модуля, которые были необходимы для правильной работы этого модуля
- (опционально) немного более подробной документации для защиты кода на будущее, которая будет полезна при дальнейшем развитии и сопровождении
- кредиты
  **Template:** [Here](https://github.com/NovaSector/NovaSector/blob/master/modular_nova/module_template.md)

## Модульные переопределения (важно!!)

Обратите внимание, что можно модульно добавлять код перед или за основной процедурой, не редактируя исходную процедуру, а обращаясь к родительской процедуре с помощью . = ..() или ..(). Аналогичным образом можно добавить новый var к существующему datum или obj, не редактируя файлы ядра.
Замечание по поводу переопределения процедур: Просто потому, что вы можете, не означает, что вы должны!
В целом, они являются хорошей идеей и поощряются, когда это возможно. Однако это не жесткое правило, и иногда правки Nova предпочтительнее. Просто постарайтесь использовать здравый смысл в этом вопросе.
Например: пожалуйста, не вставляйте всю TG-процедуру в модульное переопределение, внесите одно небольшое изменение, а затем заявите, что она «полностью модульная». Эти процедуры - абсолютный кошмар для поддержки, потому что как только что-то изменится, вам придется обновлять переопределенную процедуру.
Иногда вы даже не знаете о существовании переопределения, если оно прекрасно компилируется и не вызывает никаких ошибок. Это часто приводит к тому, что функции, которые были добавлены выше по течению, здесь отсутствуют. Так что да. Избегайте этого. Нет ничего страшного, если что-то не является полностью модульным. Иногда это лучший выбор.
Лучшие кандидаты на модульные переопределения proc - это те, в которых вы можете просто добавить что-то после вызова родителя или хитро вплести вызов родителя в середину, чтобы достичь желаемого эффекта.
Производительность также следует учитывать, когда вы переопределяете горячую процедуру (например, Life()), поскольку каждый дополнительный вызов увеличивает накладные расходы. В таких случаях редактирование Nova намного производительнее. Однако для большинства процедур об этом не нужно думать.

## Эти модульные переопределения должны храниться в master_files, и вы должны избегать их размещения в модулях, насколько это возможно.

Для простоты предположим, что вы хотите заставить оружие искрить при выстреле, для имитации дульной вспышки или по каким-либо другим причинам, и потенциально вы хотите использовать это с любыми видами оружия.
Вы можете начать с того, что добавите в модульный файл переменную var.

```dm
/obj/item/gun
    var/muzzle_flash = TRUE
```

И все будет работать как надо. После этого, допустим, вы захотите проверить этот var и породить искры после выстрела. Зная, что исходная процедура, вызываемая при выстреле, имеет вид:

```dm
/obj/item/gun/proc/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
```

вы можете определить для него дочернюю процедуру, которая будет вставлена в цепочку наследования связанных с ней процедур (большие слова, но в таких простых случаях, как этот, вам не нужно беспокоиться)

```dm
/obj/item/gun/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
    . = ..() //. is the default return value, we assign what the parent proc returns to it, as we call it before ours
    if(muzzle_flash)
        spawn_sparks(src) //For simplicity, I assume you've already made a proc for this
```

На этом основные моменты заканчиваются.

## Немодульные изменения в коде ядра - ВАЖНО

Время от времени наступает момент, когда редактирование файлов ядра становится неизбежным.
Пожалуйста, не забудьте записать их в readme.md модуля. Любые изменения файлов.
В этих случаях мы решили применить следующую конвенцию с примерами:

- Дополнение:

```dm
// NOVA EDIT ADDITION START - SHUTTLE_TOGGLE - (Необязательная причина/комментарий)
var/adminEmergencyNoRecall = FALSE
var/lastMode = SHUTTLE_IDLE
var/lastCallTime = 6000
// NOVA EDIT ADDITION END
```

- Удаление:

```dm
/* // NOVA EDIT REMOVAL START - SHUTTLE_TOGGLE - (Optional Reason/comment)
for(var/obj/docking_port/stationary/S in stationary)
  if(S.id = id)
    return S
*/ // NOVA EDIT REMOVAL END
WARNING("couldn't find dock with id: [id]")
```

И для любых удалений, которые перемещаются в другие файлы*: *Пожалуйста, избегайте этого, но делайте это только в том случае, если нет другого выхода.\*

```dm
/* // NOVA EDIT REMOVAL START - SHUTTLE_TOGGLE - (Moved to modular_nova/shuttle_toggle/randomverbs.dm)
/client/proc/admin_call_shuttle()
set category = "Admin - Events"
set name = "Call Shuttle"
if(EMERGENCY_AT_LEAST_DOCKED)
  return
if(!check_rights(R_ADMIN))
  return
var/confirm = alert(src, "You sure?", "Confirm", "Yes", "No")
if(confirm != "Yes")
  return
SSshuttle.emergency.request()
SSblackbox.record_feedback("tally", "admin_verb", 1, "Call Shuttle") //If you are copy-pasting this, ensure the 2nd parameter is unique to the new proc!
log_admin("[key_name(usr)] admin-called the emergency shuttle.")
message_admins(span_adminnotice("[key_name_admin(usr)] admin-called the emergency shuttle."))
return
*/ //NOVA EDIT REMOVAL END
```

- Изменения:

```dm
if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE, SHUTTLE_DISABLED) // NOVA EDIT CHANGE - ORIGINAL: if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE)
```

Всегда приводите оригинальный код (всю строку!) и используйте то же форматирование, что и выше.
Многострочных изменений следует избегать. Либо вставляйте несколько однострочных изменений, либо делайте это вместо них:
Пример: Комбинация удаления/добавления. Это предпочтительный способ работы с изменениями, которые занимают более одной строки и имеют разные уровни отступа.

```dm
/* // NOVA EDIT REMOVAL START - Adds conditional
  	return 1
*/ // NOVA EDIT REMOVAL
// NOVA EDIT ADDITION START - Adds conditional
	if(!isnull(src))
  	return 1
// NOVA EDIT ADDITION END
Так нам гораздо проще разрешать различия во время конфликтов слияния, потому что это делает различия очень ясными и понятными
```

# Исключительные случаи модульного кода

Из каждого правила есть исключения, обусловленные множеством обстоятельств. Не думайте об этом слишком много.

## Определения

В связи с тем, как byond загружает файлы, возникла необходимость создать отдельную папку для работы с нашими модульными определениями. Это папка `code/__DEFINES/~nova_defines`, в которой вы можете добавлять их к существующим файлам или создавать эти файлы по мере необходимости.

Если у вас есть дефиниция, которая используется более чем в одном файле, она должна быть объявлена здесь.
Если у вас есть define, который используется в одном файле и больше нигде не будет использоваться, объявите его вверху, а #undef MY_DEFINE - внизу файла. Это нужно для того, чтобы сохранить чистоту контекстных меню и не запутать тех, кто использует IDE с автозаполнением.
